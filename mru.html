<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>MRU — Strada cartoon + Timeline centrata (bordo protetto)</title>
<style>
  :root{ --bg1:#e9eef5; --bg2:#dbe6f3; --panel:#ffffff; --ink:#0f172a; --muted:#64748b; --blue:#2563eb; --orange:#f97316; }
  *{box-sizing:border-box}
  body{margin:0; font-family:Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif; background:linear-gradient(180deg,var(--bg1),var(--bg2)); color:var(--ink); padding:1rem;}
  header{display:flex; justify-content:space-between; align-items:center; gap:1rem; margin-bottom:8px}
  h1{margin:0; font-size:clamp(1.1rem,1.6rem,2rem)}
  .layout{display:grid; gap:1rem; grid-template-columns:1fr;}
  @media (min-width: 980px){.layout{grid-template-columns: 1.2fr .8fr}}
  .card{background:var(--panel); border-radius:16px; box-shadow:0 10px 30px rgba(15,23,42,.08); padding:12px}
  canvas{width:100%; height:100%; display:block; border-radius:12px}
  .scene{aspect-ratio:16/9}
  .graph{aspect-ratio:16/9}
  .controls{display:flex; flex-wrap:wrap; gap:.8rem; align-items:center; margin-top:.6rem}
  .ctrl{background:var(--panel); padding:.65rem .9rem; border-radius:12px; box-shadow:0 6px 16px rgba(15,23,42,.06); display:flex; align-items:center; gap:.5rem}
  input[type=range]{width:260px}
  .btn{border:0; background:var(--blue); color:#fff; padding:.6rem .9rem; border-radius:10px; font-weight:700; cursor:pointer}
  .btn.secondary{background:#0f172a}
  .pill{background:#0ea5e9; color:#fff; padding:.35rem .7rem; border-radius:999px; font-weight:700; display:inline-block; margin-right:.4rem}
  .legend{position:absolute; right:.6rem; top:.6rem; background:rgba(255,255,255,.85); padding:.35rem .6rem; border-radius:8px; font-size:.8rem; box-shadow:0 2px 8px rgba(0,0,0,.08)}
</style>
</head>
<body>
  <header>
    <h1>MRU — Auto cartoon centrale, strada in movimento • Timeline orizzontale</h1>
    <div style="font-size:.9rem;color:#334155">v>0 vista da dietro • v<0 vista da davanti • punto del grafico fisso al centro • bordo protetto</div>
  </header>

  <section class="layout">
    <div class="card" style="position:relative">
      <div class="legend">La strada scorre in funzione di v. Niente freccia; vista cambia col segno di v.</div>
      <canvas id="scene" class="scene"></canvas>
      <div class="controls">
        <div class="ctrl"><label for="vel">Velocità (m/s)</label><input id="vel" type="range" min="-40" max="40" step="1" value="18"><strong id="velVal">18</strong></div>
        <button id="pp" class="btn">Pausa</button>
        <button id="reset" class="btn secondary">Reset</button>
        <span class="pill" id="kpiT">t = 0.0 s</span>
        <span class="pill" id="kpiS">s = 0.0 m</span>
        <span class="pill" id="kpiV">v = 18 m/s</span>
      </div>
    </div>

    <div class="card" style="position:relative">
      <div class="legend">Grafico s–t centrato (timeline). Bordi di sicurezza in alto/basso e a sinistra/destra.</div>
      <canvas id="graph" class="graph"></canvas>
    </div>
  </section>

<script>
(function(){
  // ===== DOM & CTX =====
  const scene = document.getElementById('scene');
  const graph = document.getElementById('graph');
  const ctx = scene.getContext('2d');
  const gtx = graph.getContext('2d');
  const velR = document.getElementById('vel');
  const velVal = document.getElementById('velVal');
  const btnPP = document.getElementById('pp');
  const btnReset = document.getElementById('reset');
  const kpiT = document.getElementById('kpiT');
  const kpiS = document.getElementById('kpiS');
  const kpiV = document.getElementById('kpiV');

  // ===== STATE =====
  let v = Number(velR.value); // m/s
  let t = 0;                  // s
  let s = 0;                  // m (accumulata)
  let playing = true;
  const points = [];          // storia {t,s}

  // ===== UI =====
  velR.addEventListener('input',()=>{ v = Number(velR.value); velVal.textContent = v.toFixed(0); kpiV.textContent = `v = ${v.toFixed(0)} m/s`; });
  btnPP.addEventListener('click',()=>{ playing = !playing; btnPP.textContent = playing ? 'Pausa' : 'Riprendi'; });
  btnReset.addEventListener('click',()=>{ t=0; s=0; points.length=0; });

  // ===== DPI-AWARE RESIZE =====
  function resize(canvas){
    const w = canvas.clientWidth, h = canvas.clientHeight; const dpr = devicePixelRatio || 1;
    if(canvas.width !== Math.floor(w*dpr) || canvas.height !== Math.floor(h*dpr)){
      canvas.width = Math.floor(w*dpr); canvas.height = Math.floor(h*dpr);
      const c = canvas.getContext('2d'); c.setTransform(dpr,0,0,dpr,0,0);
    }
  }
  const ro = new ResizeObserver(()=>{ resize(scene); resize(graph); });
  ro.observe(scene); ro.observe(graph);

  // ===== SCENA: AUTO CARTOON CENTRALE, STRADA IN MOVIMENTO =====
  let laneOffset = 0;           // scorrimento segnaletica
  const pxPerMeter = 6;         // scala per la strada
  const dashLen = 36, dashGap = 44;

  function drawScene(dt){
    const w = scene.clientWidth, h = scene.clientHeight; ctx.clearRect(0,0,w,h);

    // cielo diurno
    const sky = ctx.createLinearGradient(0,0,0,h*0.6); sky.addColorStop(0,'#cfe3ff'); sky.addColorStop(1,'#f2f7ff'); ctx.fillStyle = sky; ctx.fillRect(0,0,w,h);

    // colline
    ctx.fillStyle = '#bcd1e6'; ctx.beginPath(); ctx.moveTo(0,h*0.55); for(let x=0;x<=w;x+=40){ ctx.lineTo(x, h*0.55 + Math.sin(x*0.008)*12); } ctx.lineTo(w,0); ctx.lineTo(0,0); ctx.closePath(); ctx.fill();

    // strada prospettica
    const horizon = h*0.62; const roadTopW = w*0.25, roadBotW = w*0.92; const cx=w/2;
    ctx.fillStyle = '#3b414a'; ctx.beginPath(); ctx.moveTo(cx-roadTopW/2,horizon); ctx.lineTo(cx+roadTopW/2,horizon); ctx.lineTo(cx+roadBotW/2,h); ctx.lineTo(cx-roadBotW/2,h); ctx.closePath(); ctx.fill();
    // bordi
    ctx.strokeStyle = '#e5e7eb'; ctx.lineWidth = 4; ctx.beginPath(); ctx.moveTo(cx-roadTopW/2,horizon); ctx.lineTo(cx-roadBotW/2,h); ctx.moveTo(cx+roadTopW/2,horizon); ctx.lineTo(cx+roadBotW/2,h); ctx.stroke();

    // segnaletica centrale che scorre (direzione opposta al moto percepito)
    laneOffset = (laneOffset + (v * dt * pxPerMeter)) % (dashLen + dashGap);
    const steps = 22;
    for(let i=0;i<steps;i++){
      const p = i/steps; const y1 = horizon + p*(h-horizon); const y2 = horizon + (p + dashLen/(h-horizon))*(h-horizon);
      const yShift = (laneOffset % (dashLen+dashGap)) * ((1-p)*0.25 + 0.75);
      const yy1 = y1 + yShift; const yy2 = y2 + yShift; if(yy1>h) continue;
      ctx.strokeStyle = '#ffffff'; ctx.lineWidth = Math.max(2, ((roadTopW+(roadBotW-roadTopW)*p)*0.01));
      ctx.beginPath(); ctx.moveTo(cx,yy1); ctx.lineTo(cx,yy2); ctx.stroke();
    }

    // AUTO cartoon al centro (vista cambia con segno di v)
    const frontView = v < 0; const carX = cx, carY = h*0.78, carW = 150, carH = 60;
    // ombra
    ctx.fillStyle = 'rgba(0,0,0,.22)'; ctx.beginPath(); ctx.ellipse(carX, carY+carH*0.55, carW*0.55, carH*0.35, 0, 0, Math.PI*2); ctx.fill();

    ctx.save(); ctx.translate(carX,carY); if(frontView) ctx.scale(-1,1);
    // carrozzeria base
    ctx.fillStyle = '#2563eb'; ctx.strokeStyle = '#0f172a'; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.roundRect(-carW/2, -carH/2, carW, carH, 14); ctx.fill(); ctx.stroke();
    // TETTUCCIO a larghezza piena (stile cartoon)
    ctx.fillStyle = '#1e40af';
    ctx.beginPath();
    ctx.roundRect(-carW/2, -carH*0.85, carW, carH*0.45, 14);
    ctx.fill();
    // VETRI ampi (parabrezza/lunotto) a larghezza piena
    ctx.fillStyle = '#93c5fd';
    ctx.beginPath(); ctx.roundRect(-carW/2 + 10, -carH*0.70, carW - 20, carH*0.34, 10); ctx.fill();
    // linea centrale del vetro (divisione)
    ctx.strokeStyle = 'rgba(255,255,255,.6)'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(0, -carH*0.68); ctx.lineTo(0, -carH*0.36); ctx.stroke();
    // dettagli frontali/posteriori
    if(frontView){
      // griglia + fari
      ctx.fillStyle = '#0f172a'; ctx.fillRect(-carW*0.22, carH*0.02, carW*0.44, 7);
      ctx.fillStyle = '#fde68a'; ctx.fillRect(-carW/2+12, -4, 18, 12); ctx.fillRect(carW/2-30, -4, 18, 12);
    } else {
      // targa + luci rosse
      ctx.fillStyle = '#e2e8f0'; ctx.fillRect(-20, 6, 40, 8);
      ctx.fillStyle = '#ef4444'; ctx.fillRect(-carW/2+12, carH*0.1, 18, 12); ctx.fillRect(carW/2-30, carH*0.1, 18, 12);
    }
    ctx.restore();
  }

  // ===== GRAFICO: PUNTO CENTRALE FISSO + TIMELINE + BORDO PROTETTO =====
  const halfWindow = 10; // secondi a sinistra e destra del punto centrale

  function drawGraph(){
    const w = graph.clientWidth, h = graph.clientHeight; gtx.clearRect(0,0,w,h);

    // padding interno fisso in px ("bordo" richiesto)
    const padL = 48, padR = 16, padT = 16, padB = 32;
    const innerW = w - (padL + padR);
    const innerH = h - (padT + padB);

    // fondo e riquadro
    gtx.fillStyle = '#ffffff'; gtx.fillRect(0,0,w,h);
    gtx.strokeStyle = '#cbd5e1'; gtx.lineWidth = 1.5; gtx.strokeRect(padL, padT, innerW, innerH);

    // finestra temporale centrata
    const tCenter = t;
    const tMin = Math.max(0, tCenter - halfWindow);
    const tMax = tCenter + halfWindow;

    // calcolo range verticale dinamico che SEGUE la discesa e mantiene MARGINI PIXEL intorno al pallino
    const windowPoints = points.filter(p => p.t >= tMin && p.t <= tMax);
    const minWin = windowPoints.length ? Math.min(...windowPoints.map(p=>p.s), s) : Math.min(0, s);
    const maxWin = windowPoints.length ? Math.max(...windowPoints.map(p=>p.s), s) : Math.max(10, s);

    // padding verticale in metri: proporzionale al range + minimo assoluto
    const baseRange = Math.max(1, maxWin - minWin);
    let sMin = Math.max(0, minWin - (0.12*baseRange + 2));
    let sMax = maxWin + (0.12*baseRange + 2);

    // assicurati che il PALLINO (s) non sia mai a meno di 30px dai bordi alto/basso
    const minPixPad = 30;
    const toY = (ss)=> h - padB - ((ss - sMin) / Math.max(1e-6, (sMax - sMin))) * innerH;
    let Yc = toY(s);
    if (Yc < padT + minPixPad) {
      // troppo vicino al top → estendi sMax
      const pixShort = (padT + minPixPad) - Yc;
      const addS = (pixShort / innerH) * (sMax - sMin);
      sMax += addS; Yc = toY(s);
    }
    if (Yc > h - padB - minPixPad) {
      // troppo vicino al bottom → estendi sMin (senza scendere sotto 0)
      const pixShort = Yc - (h - padB - minPixPad);
      const addS = (pixShort / innerH) * (sMax - sMin);
      sMin = Math.max(0, sMin - addS); Yc = toY(s);
    }

    const tx = (tt)=> padL + ((tt - (tCenter - halfWindow)) / (2*halfWindow)) * innerW;
    const sy = (ss)=> h - padB - ((ss - sMin) / Math.max(1e-6, (sMax - sMin))) * innerH;

    // Griglia TIMELINE: linee verticali che scorrono (1 s)
    gtx.strokeStyle = '#e5e7eb'; gtx.lineWidth = 1; gtx.setLineDash([6,6]);
    const firstTick = Math.ceil(tMin);
    for(let ttick = firstTick; ttick <= tMax; ttick += 1){
      const x = tx(ttick); gtx.beginPath(); gtx.moveTo(x, padT); gtx.lineTo(x, h - padB); gtx.stroke();
    }
    gtx.setLineDash([]);

    // Assi
    gtx.strokeStyle = '#94a3b8'; gtx.lineWidth = 1.5;
    gtx.beginPath(); gtx.moveTo(padL, h - padB); gtx.lineTo(w - padR, h - padB); gtx.moveTo(padL, h - padB); gtx.lineTo(padL, padT); gtx.stroke();

    // Etichette
    gtx.fillStyle = '#0f172a'; gtx.font = '12px Inter, system-ui, sans-serif';
    gtx.fillText('Tempo (s)', w/2-28, h-10);
    gtx.save(); gtx.translate(18, h/2+28); gtx.rotate(-Math.PI/2); gtx.fillText('Spazio (m)', 0, 0); gtx.restore();

    // Curva s–t (storia) con bordo protetto
    gtx.strokeStyle = '#2563eb'; gtx.lineWidth = 2; gtx.beginPath();
    let moved=false;
    for(const p of points){ if(p.t < tMin || p.t > tMax) continue; const X=tx(p.t), Y=sy(p.s); if(!moved){ gtx.moveTo(X,Y); moved=true; } else { gtx.lineTo(X,Y); } }
    if(moved) gtx.stroke();

    // Punto centrale — fisso in X, alla quota di s attuale
    const Xc = padL + innerW/2; const Ycc = sy(s);
    gtx.fillStyle = '#2563eb'; gtx.beginPath(); gtx.arc(Xc, Ycc, 5, 0, Math.PI*2); gtx.fill();

    // Crocette incrociate
    gtx.strokeStyle = '#94a3b8'; gtx.setLineDash([6,6]); gtx.beginPath(); gtx.moveTo(padL, Ycc); gtx.lineTo(w - padR, Ycc); gtx.moveTo(Xc, padT); gtx.lineTo(Xc, h - padB); gtx.stroke(); gtx.setLineDash([]);

    // Ticks numerici
    gtx.fillStyle = '#334155'; gtx.font = '11px Inter, system-ui, sans-serif';
    const xticks = 6; for(let i=0;i<=xticks;i++){ const tt = tMin + i*(tMax - tMin)/xticks; const x = tx(tt); gtx.fillText(tt.toFixed(0), x-8, h-12); }
    const yticks = 5; for(let i=0;i<=yticks;i++){ const ss = sMin + i*(sMax - sMin)/yticks; const y = sy(ss); gtx.fillText(ss.toFixed(0), 6, y+4); }
  }

  // ===== LOOP =====
  let last = performance.now();
  function frame(now){
    resize(scene); resize(graph);
    const rawdt = (now - last)/1000; last = now; const dt = Math.min(0.05, rawdt) * (playing ? 1 : 0);

    // Integrazione MRU
    t += dt; s += v * dt;

    // registra storia (50 Hz)
    if(points.length===0 || t - points[points.length-1].t >= 0.02){ points.push({t, s}); if(points.length>6000) points.splice(0,1500); }

    // KPI
    kpiT.textContent = `t = ${t.toFixed(1)} s`; kpiS.textContent = `s = ${s.toFixed(1)} m`;

    // Draw
    drawScene(dt);
    drawGraph();

    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);
})();
</script>
</body>
</html>
